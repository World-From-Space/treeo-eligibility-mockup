import rasterio
from rasterio.transform import from_origin
import random
from typing import Dict, Any, Union

import numpy as np
import rasterio
from rasterio.transform import from_origin
from rasterio.warp import transform_geom
from shapely.geometry import Polygon, Point, mapping, shape


def predict_forest(
        aoi: Polygon,
        crs: str = "EPSG:3857"
) -> Dict[str, Union[np.ndarray, Dict[str, Any]]]:
    """
    Predicts forest cover for a given Area of Interest (AOI) polygon. The function
    returns dummy raster data at Sentinel-2 resolution (10 m), where each pixel
    represents a random forest presence value.

    Parameters
    ----------
    aoi : Polygon
        A Shapely Polygon defining the area of interest. Coordinates are assumed
        to be in WGS84 (EPSG:4326).
    crs : str, optional
        The target Coordinate Reference System for the AOI (default "EPSG:3857").

    Returns
    -------
    result : Dict[str, Union[np.ndarray, Dict[str, Any]]]
        A dictionary containing:
          - "data": np.ndarray of shape (height, width), dtype=int16,
                    where each cell contains a random value (0 or 1) if the pixel
                    center is within the input polygon, or -9 otherwise.
          - "meta": dict with metadata describing:
                - "bounds": tuple (minx, miny, maxx, maxy) of the polygon
                - "width": int, number of columns (pixels) in X direction
                - "height": int, number of rows (pixels) in Y direction
                - "pixel_size": float, 10.0 (meters)
                - "dtype": "int16"
                - "count": 1
    """
    geom = mapping(aoi)
    geom_proj = transform_geom("EPSG:4326", crs, geom)
    aoi = shape(geom_proj)

    # Sentinel-2 pixel size
    pixel_size: float = 10.0  # meters

    # Compute the bounding box of the input polygon
    minx, miny, maxx, maxy = aoi.bounds  # type: float, float, float, float

    # Compute the number of pixels needed in X and Y directions
    width: int = int(np.ceil((maxx - minx) / pixel_size))
    height: int = int(np.ceil((maxy - miny) / pixel_size))

    # generate random boolean data for the raster
    dummy_array: np.ndarray = np.full((height, width), fill_value=-9, dtype=np.int16)
    for i in range(height):
        for j in range(width):
            # Calculate the pixel center coordinates
            pixel_center_x: float = minx + (j + 0.5) * pixel_size
            pixel_center_y: float = maxy - (i + 0.5) * pixel_size

            # Create a Point for the pixel center
            pixel_center: Point = Point(pixel_center_x, pixel_center_y)

            # Check if the pixel center is within the polygon
            if aoi.contains(pixel_center):
                dummy_array[i, j] = random.choice([0, 1])

    # Prepare output metadata
    out_meta: Dict[str, Any] = {
        "bounds": (minx, miny, maxx, maxy),
        "width": width,
        "height": height,
        "pixel_size": pixel_size,
        "dtype": "int16",
        "count": 1
    }

    return {
        "data": dummy_array,
        "meta": out_meta
    }


def save_forest_prediction_to_geotiff(
        result: Dict[str, Union[np.ndarray, Dict[str, Any]]],
        output_path: str = "forest_prediction.tif",
        crs: str = "EPSG:3857"
) -> None:
    """
    Generates a dummy boolean raster at Sentinel-2 (10 m) resolution over the polygon's extent
    and writes the result to a GeoTIFF file.

    Parameters
    ----------
    result : Dict[str, Union[np.ndarray, Dict[str, Any]]]
        A dictionary containing raster data and metadata generated by the `predict_forest` function.
    output_path : str, optional
        Path (including filename) where the GeoTIFF will be written (default "forest_prediction.tif").
    crs : str, optional
        The target Coordinate Reference System for the output (default "EPSG:3857").
    """

    raster_data: np.ndarray = result["data"]  # shape (height, width), dtype=bool
    meta: dict = result["meta"]  # contains bounds, width, height, pixel_size, etc.

    minx, miny, maxx, maxy = meta["bounds"]
    pixel_size: float = meta["pixel_size"]
    height: int = meta["height"]
    width: int = meta["width"]

    # Compute an Affine transform: origin at (minx, maxy), pixel_size Ã— pixel_size
    transform = from_origin(
        minx,  # westernmost x
        maxy,  # northernmost y
        pixel_size,  # x resolution (10 m)
        pixel_size  # y resolution (10 m)
    )

    # Build the raster profile for GeoTIFF
    profile = {
        "driver": "GTiff",
        "height": height,
        "width": width,
        "count": 1,
        "dtype": "int16",
        "crs": crs,
        "transform": transform,
        "nodata": -9,
        "compress": "lzw"
    }

    # Write out the GeoTIFF
    with rasterio.open(output_path, "w", **profile) as dst:
        dst.write(raster_data, 1)
